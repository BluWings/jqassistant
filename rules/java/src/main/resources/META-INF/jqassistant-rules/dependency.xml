<jqa:jqassistant-rules xmlns:jqa="http://www.buschmais.com/jqassistant/core/analysis/rules/schema/v1.0">

    <concept id="dependency:TypeDependency">
        <description>Creates a DEPENDS_ON relationship between types if there are field or method dependencies between them.</description>
        <cypher><![CDATA[
            MATCH 
            	t1:TYPE-[:CONTAINS*0..1]->(typeFieldOrMethod)-[:DEPENDS_ON|ANNOTATED_BY|THROWS]->t2:TYPE
			WHERE 
				t1<>t2
			CREATE UNIQUE 
				(t1)-[:DEPENDS_ON]->(t2)
			RETURN 
				COUNT(t1) as count
        ]]></cypher>
    </concept>

    <concept id="dependency:PackageDependency">
        <requiresConcept refId="dependency:TypeDependency"/>
        <description>Creates a DEPENDS_ON relationship between packages if there are type dependencies between them.</description>
        <cypher><![CDATA[
			MATCH  
				(p1:PACKAGE)-[:CONTAINS]->(t1:TYPE)-[:DEPENDS_ON|ANNOTATED_BY|EXTENDS|IMPLEMENTS]->(t2:TYPE)<-[:CONTAINS]-(p2:PACKAGE)
			WHERE 
				t1<>t2 AND p1<>p2
			CREATE UNIQUE 
				(p1)-[:DEPENDS_ON]->(p2)
			RETURN 
				COUNT(p1) as count
        ]]></cypher>
    </concept>

    <constraint id="dependency:CyclicPackageDependency">
        <requiresConcept refId="dependency:PackageDependency"/>
        <description>There must be no cyclic package dependencies.</description>
        <cypher><![CDATA[
			MATCH
				p1:PACKAGE-[:DEPENDS_ON]->p2:PACKAGE,
				path=shortestPath(p2-[:DEPENDS_ON*]->p1:PACKAGE)
			WHERE
				p1<>p2
			RETURN
				p1 as package, extract(p in nodes(path) : p.FQN) as cycle
			ORDER BY
				package	
        ]]></cypher>
    </constraint>

    <constraint id="dependency:CyclicTypeDependency">
        <requiresConcept refId="dependency:TypeDependency"/>
        <requiresConcept refId="dependency:PackageDependency"/>
        <description>There must be no cyclic type dependencies.</description>
        <cypher><![CDATA[
            MATCH
                p1:PACKAGE-[:DEPENDS_ON*0..1]->p2:PACKAGE,
                shortestPath(p2-[:DEPENDS_ON*]->p1:PACKAGE)
            WITH
                p1, p2
            MATCH
                p1-[:CONTAINS]->t1:TYPE,
                p2-[:CONTAINS]->t2:TYPE,
                t1-[:DEPENDS_ON]->t2,
                path=shortestPath(t2-[:DEPENDS_ON*]->t1)
            WHERE
                NOT(
                  t1=t2 OR (t1)-[:CONTAINS]-(t2)
                )
            RETURN
                length(path) as length, extract(p in nodes(path) : p.FQN) as cycle
        ]]></cypher>
    </constraint>

</jqa:jqassistant-rules>