<jqa:jqassistant-rules xmlns:jqa="http://www.buschmais.com/jqassistant/core/analysis/rules/schema/v1.0">

    <concept id="dependency:ClassDependency">
        <description>Creates a DEPENDS_ON relationship between classes if there are field or method dependencies between them.</description>
        <cypher><![CDATA[
            MATCH 
            	c1:CLASS-[:CONTAINS*0..1]->(classFieldOrMethod)-[:DEPENDS_ON|ANNOTATED_BY|THROWS]->c2:CLASS
			WHERE 
				c1<>c2
			CREATE UNIQUE 
				(c1)-[:DEPENDS_ON]->(c2)
			RETURN 
				COUNT(c1) as count
        ]]></cypher>
    </concept>

    <concept id="dependency:PackageDependency">
        <requiresConcept refId="dependency:ClassDependency"/>
        <description>Creates a DEPENDS_ON relationship between packages if there are class dependencies between them.</description>
        <cypher><![CDATA[
			MATCH  
				(p1:PACKAGE)-[:CONTAINS]->(c1:CLASS)-[:DEPENDS_ON|ANNOTATED_BY|EXTENDS|IMPLEMENTS]->(c2:CLASS)<-[:CONTAINS]-(p2:PACKAGE)
			WHERE 
				c1<>c2 AND p1<>p2
			CREATE UNIQUE 
				(p1)-[:DEPENDS_ON]->(p2)
			RETURN 
				COUNT(p1) as count
        ]]></cypher>
    </concept>

    <constraint id="dependency:CyclicPackageDependency">
        <requiresConcept refId="dependency:PackageDependency"/>
        <description>There must be no cyclic package dependencies.</description>
        <cypher><![CDATA[
			MATCH
				p1:PACKAGE-[:DEPENDS_ON]->p2:PACKAGE,
				path=shortestPath(p2-[:DEPENDS_ON*]->p1:PACKAGE)
			WHERE
				p1<>p2
			RETURN
				p1 as package, extract(p in nodes(path) : p.FQN) as cycle
			ORDER BY
				package	
        ]]></cypher>
    </constraint>

    <constraint id="dependency:CyclicClassDependency">
        <requiresConcept refId="dependency:ClassDependency"/>
        <requiresConcept refId="dependency:PackageDependency"/>
        <description>There must be no cyclic class dependencies.</description>
        <cypher><![CDATA[
            MATCH
                p1:PACKAGE-[:DEPENDS_ON*0..1]->p2:PACKAGE,
                shortestPath(p2-[:DEPENDS_ON*]->p1:PACKAGE)
            WITH
                p1, p2
            MATCH
                p1-[:CONTAINS]->c1:CLASS,
                p2-[:CONTAINS]->c2:CLASS,
                c1-[:DEPENDS_ON]->c2,
                path=shortestPath(c2-[:DEPENDS_ON*]->c1)
            WHERE
                NOT(
                  c1=c2 AND (c1)-[:CONTAINS]-(c2)
                )
            RETURN
                length(path) as length, extract(p in nodes(path) : p.FQN) as cycle
        ]]></cypher>
    </constraint>

</jqa:jqassistant-rules>